//
// Created by Thomas Vallentin on 19/03/2022.
//

#include "RenderDelegate.h"

#include "Rebound/Renderer/Hop/Backends/OpenGL/OpenGLRenderer.h"

#include "Rebound/Renderer/RenderScene.h"
#include "Rebound/Renderer/Camera.h"

namespace Hop {

    std::vector<DrawItem*> RenderDelegate::s_DrawItems;
    RenderAPI RenderDelegate::s_renderApi = RenderAPI::OpenGL;
    RenderHints RenderDelegate::s_renderHints;

    void RenderDelegate::SetRenderHints(const RenderHints &hints) {
        switch (GetAPI()) {
            case RenderAPI::None:    return;
            case RenderAPI::OpenGL:  OpenGLRenderer::SetRenderHints(hints);
        }
    }

    bool RenderDelegate::Render(Rebound::Camera *camera) {
        s_sceneData.viewProjectionMatrix = camera->GetViewProjectionMatrix();

        // TODO: Now we use directly the RenderEntities generated by the RenderDelegate and send
        //  them to the Renderer. We should probably add a layer between them, generate Items
        //  that will be drawn by the Renderer (OpenGL, Vulcan, etc...) so that the
        //  RenderEntities only take care of syncing the Item with the Entities
        switch (GetAPI()) {
            case RenderAPI::None:    break;  // TODO: Add warning
            case RenderAPI::OpenGL:  OpenGLRenderer::Render(m_scene->Index(), camera); break;
        }

        return true;
    }

    Rebound::RenderEntity *
    RenderDelegate::CreateRenderEntity(const Rebound::EntityDataHandle &handle) {
        return nullptr;
    }

}
